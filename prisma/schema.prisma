datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

model User {
  id                 String    @id @default(auto()) @map("_id") @db.ObjectId
  name               String?
  email              String?   @unique
  emailVerified      DateTime?
  previousEmail      String?
  image              String?
  accounts           Account[]
  sessions           Session[]
  termsAndConditions Boolean   @default(false)
  username           String?   @unique
  role               String?

  // Security fields for account lockout
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime?

  // Profile fields
  firstName             String?
  lastName              String?
  phone                 String?
  addressLine1          String?
  addressLine2          String?
  city                  String?
  state                 String?
  zipCode               String?
  country               String?
  allowSmsNotifications Boolean? @default(false)

  // Optional for WebAuthn support
  Authenticator Authenticator[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes for performance
  @@index([failedLoginAttempts])
  @@index([lockedUntil])
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@index([provider])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([expires])
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @id @map("_id")
  userId               String  @db.ObjectId
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, credentialID])
}

model Image {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  caption   String?
  artist    Artist   @relation(fields: [artistId], references: [id])
  artistId  String   @db.ObjectId
  release   Release? @relation(fields: [releaseId], references: [id])
  releaseId String?  @db.ObjectId
  group     Group?   @relation(fields: [groupId], references: [id])
  groupId   String?  @db.ObjectId
  track     Track?   @relation(fields: [trackId], references: [id])
  trackId   String?  @db.ObjectId
  url       Url?     @relation(fields: [urlId], references: [id])
  urlId     String?  @db.ObjectId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([artistId])
  @@index([releaseId])
  @@index([groupId])
  @@index([trackId])
  @@index([urlId])
}

model Group {
  id           String        @id @default(auto()) @map("_id") @db.ObjectId
  name         String
  formedOn     DateTime?
  endedOn      DateTime?
  bio          String? // Markdown supported post-MVP, for now just plain text blurb
  shortBio     String? // Ditto md support; A shorter version of the bio for use in thumbnails and listings
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  images       Image[]
  artistGroups ArtistGroup[]
  urls         Url[]

  @@index([name])
}

enum Platform {
  SPOTIFY
  APPLE_MUSIC
  BANDCAMP
  YOUTUBE
  SOUNDCLOUD
  AMAZON_MUSIC
  FACEBOOK
  TWITTER
  INSTAGRAM
  BLUESKY
  TIKTOK
  WEBSITE
  PATREON
  DISCOGS
}

enum Format {
  DIGITAL
  MP3_320KBPS
  MP3_256KBPS
  MP3_192KBPS
  MP3_128KBPS
  FLAC
  ALAC
  WAV
  AIFF
  AAC
  OGG_VORBIS
  WMA
  CD
  VINYL
  VINYL_7_INCH
  VINYL_10_INCH
  VINYL_12_INCH
  VINYL_180G
  VINYL_COLORED
  VINYL_PICTURE_DISC
  VINYL_GATEFOLD
  VINYL_SPLATTERED
  VINYL_ETCHED
  VINYL_45RPM
  VINYL_33RPM
  VINYL_TRANSPARENT
  VINYL_DOUBLE_LP
  VINYL_TRIPLE_LP
  VINYL_QUAD_LP
  CASSETTE
  VIDEO
  OTHER
}

// Model to store various URLs associated with an artist on various platforms such as Bandcamp, Spotify, Apple Music, etc.
// artistUrlPrefix will be derived from the platform type and combined with the url field to yield the full URL
model Url {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  artist      Artist       @relation(fields: [artistId], references: [id])
  artistId    String       @db.ObjectId
  release     Release?     @relation(fields: [releaseId], references: [id])
  releaseId   String?      @db.ObjectId
  group       Group?       @relation(fields: [groupId], references: [id])
  groupId     String?      @db.ObjectId
  platform    Platform // Platform.SPOTIFY, Platform.APPLE_MUSIC, etc.
  url         String // TODO: validate that this is a well-formed URL
  images      Image[]
  releaseUrls ReleaseUrl[]

  @@index([artistId])
  @@index([platform])
}

model Genre {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Label {
  id           String        @id @default(auto()) @map("_id") @db.ObjectId
  name         String        @unique
  signedOn     DateTime?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  artistLabels ArtistLabel[]
}

model Artist {
  id                  String          @id @default(auto()) @map("_id") @db.ObjectId
  firstName           String
  middleName          String? // Optional middle name; if stored with commas, split into array on retrieval
  surname             String // aka last name; if stored with commas, split into array on retrieval
  akaNames            String? // aka_name = also known as names; if stored with commas, split into array on retrieval
  displayName         String? // The primary name to display for the artist; Will be derived from other name fields if not provided
  title               String? // e.g., Dr., Prof., Sir, D.J., M.C.
  suffix              String? // e.g., Jr., Sr., III, PhD
  phone               String? // internal only; contact phone number; if stored with commas, split into array on retrieval
  address1            String? // internal only; street address line 1
  address2            String? // internal only; street address line 2, ie. apartment or suite number
  city                String? // internal only; city
  state               String? // internal only; state
  postalCode          String? // internal only; postal code
  country             String? // internal only; country
  bio                 String? // Markdown supported post-MVP, for now just plain text blurb
  shortBio            String? // Ditto md support; A shorter version of the bio for use in thumbnails and listings
  altBio              String? // Ditto md support; An alternative bio for special use cases
  slug                String          @unique // Prepopulate or choose a URL-friendly dasherized unique identifier; the artists page will be at /artists/{slug}
  genres              String? // If stored with commas, split into array on retrieval; genres are created in Genre collection, but denormalized here for easy querying
  bornOn              DateTime? // Always feature artist on their birthday if known
  diedOn              DateTime?
  featuredOn          DateTime? // Date when artist was featured along with their latest release
  featuredTrack       Track?          @relation(fields: [featuredTrackId], references: [id])
  featuredTrackId     String?         @db.ObjectId
  featuredDescription String? // Markdown supported post-MVP; A special description to use when the artist is featured; keep it brief
  publishedOn         DateTime? // Date when the artist was published
  createdAt           DateTime        @default(now())
  updatedAt           DateTime?       @updatedAt
  archivedAt          DateTime? // Soft delete timestamp
  deactivatedAt       DateTime? // Date when the artist was deactivated; ie. left the label
  reactivatedAt       DateTime? // Date when the artist was reactivated; ie. re-signed with the label
  notes               String[] // internal only notes about the artist not meant for public display; markdown support post-MVP
  images              Image[]
  artistLabels        ArtistLabel[] // All labels the artist is/was associated with
  artistGroups        ArtistGroup[] // Names of musical groups the artist is/was associated with
  artistReleases      ArtistRelease[] // Releases associated with the artist, including Tracks released
  urls                Url[] // Various platform URLs associated with the artist
  tags                String? // If stored with commas, split into array on retrieval; prefer dasherized case tags, ie. "indie-rock", "synth-pop"
  isPseudonymous      Boolean         @default(false) // Don't display real name if true; use first of akaNames or displayName instead in that order
  isActive            Boolean         @default(true) // Whether the artist is currently active; used for filtering in listings
  instruments         String? // If stored with commas, split into array on retrieval; list of instruments the artist plays from primary to occasional
  artistUrls          ArtistUrl[]

  @@index([isActive])
  @@index([featuredOn])
  @@index([firstName, surname])
  @@index([displayName])
}

model ArtistGroup {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  artist   Artist @relation(fields: [artistId], references: [id])
  artistId String @db.ObjectId
  group    Group  @relation(fields: [groupId], references: [id])
  groupId  String @db.ObjectId

  @@unique([artistId, groupId])
  @@index([artistId])
  @@index([groupId])
}

model ArtistLabel {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  artist   Artist @relation(fields: [artistId], references: [id])
  artistId String @db.ObjectId
  label    Label  @relation(fields: [labelId], references: [id])
  labelId  String @db.ObjectId

  @@unique([artistId, labelId])
  @@index([artistId])
  @@index([labelId])
}

model ArtistRelease {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  artist    Artist  @relation(fields: [artistId], references: [id])
  artistId  String  @db.ObjectId
  release   Release @relation(fields: [releaseId], references: [id])
  releaseId String  @db.ObjectId

  @@unique([artistId, releaseId])
  @@index([artistId])
  @@index([releaseId])
}

model ArtistUrl {
  id       String   @id @default(auto()) @map("_id") @db.ObjectId
  artist   Artist   @relation(fields: [artistId], references: [id])
  artistId String   @db.ObjectId
  platform Platform // Platform.SPOTIFY, Platform.APPLE_MUSIC, etc.
  url      String

  @@unique([artistId, platform])
  @@index([artistId])
  @@index([platform])
}

// Add to Tag collection as new tags are created. Remove hash before storing
model Tag {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Variants {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  description String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ReleaseUrl {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  release   Release @relation(fields: [releaseId], references: [id])
  releaseId String  @db.ObjectId
  url       Url     @relation(fields: [urlId], references: [id])
  urlId     String  @db.ObjectId

  @@index([releaseId])
}

model Release {
  id                  String          @id @default(auto()) @map("_id") @db.ObjectId
  title               String
  labels              String[]
  releasedOn          DateTime // Release date sans time component
  catalogNumber       String?
  coverArt            String
  description         String? // Markdown supported post-MVP; A general description of the release for use in various contexts; keep it brief
  downloadUrls        String[]
  formats             Format[] // enum
  // Array of extended format data objects with structure:
  // { format: Format, color?: string, isLimitedEdition: boolean, unitsPressed?: number, isSoldOut: boolean, hasLinerNotes: boolean, specialFeatures?: string[], bandcampUrl?: string, description?: string, notes?: string[] }
  extendedData        Json[]
  images              Image[]
  tags                String[]
  notes               String[]
  executiveProducedBy String[]
  coProducedBy        String[]
  masteredBy          String[]
  mixedBy             String[]
  recordedBy          String[]
  artBy               String[]
  designBy            String[]
  photographyBy       String[]
  linerNotesBy        String[]
  imageTypes          String[]
  variants            String[]
  releaseTracks       ReleaseTrack[]
  artistReleases      ArtistRelease[]
  releaseUrls         ReleaseUrl[]
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  publishedAt         DateTime? // Date when the release was published
  urls                Url[]

  @@index([releasedOn])
  @@index([title])
}

model Track {
  id            String         @id @default(auto()) @map("_id") @db.ObjectId
  title         String
  duration      Int // Duration in seconds
  audioFile     String // URL or file path to the audio file
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  images        Image[]
  position      Int // Position of the track in the release 0-based index
  releaseTracks ReleaseTrack[]
  artists       Artist[]

  @@index([title])
  @@index([position])
}

model ReleaseTrack {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  release   Release @relation(fields: [releaseId], references: [id])
  releaseId String  @db.ObjectId
  track     Track   @relation(fields: [trackId], references: [id])
  trackId   String  @db.ObjectId

  @@unique([releaseId, trackId])
  @@index([releaseId])
  @@index([trackId])
}

model Instrument {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
