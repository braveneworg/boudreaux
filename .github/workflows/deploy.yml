name: CI/CD - Build, Publish, Deploy (Clean)

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: cicd-${{ github.ref_name }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_REPO: ghcr.io/${{ github.repository_owner }}/boudreaux
  WEBSITE_IMAGE: ghcr.io/${{ github.repository_owner }}/boudreaux/website
  NGINX_IMAGE: ghcr.io/${{ github.repository_owner }}/boudreaux/nginx

permissions:
  contents: read
  packages: write

jobs:
  build:
    name: Build Next.js, sync CDN, build & push images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build Next.js
        env:
          SKIP_ENV_VALIDATION: "true"
          # Use a placeholder DB URL; build shouldn't require a live DB connection
          DATABASE_URL: "mongodb://localhost:27017/build-placeholder"
          NEXT_PUBLIC_CLOUDFLARE_SITE_KEY: ${{ secrets.NEXT_PUBLIC_CLOUDFLARE_SITE_KEY }}
        run: npm run build

      - name: Sync to CDN (includes .next/static)
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
          CDN_DOMAIN: ${{ secrets.CDN_DOMAIN }}
        run: npm run sync:cdn:no-build

      - name: Log in to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_USERNAME || github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver-opts: network=host

      - name: Set up QEMU for cross-arch builds
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      - name: Show buildx platforms
        run: docker buildx ls

      - name: Package .next build for Docker context
        run: tar -czf .next-build.tar.gz .next

      - name: Build multi-arch website image (with retry)
        env:
          NEXT_PUBLIC_CLOUDFLARE_SITE_KEY: ${{ secrets.NEXT_PUBLIC_CLOUDFLARE_SITE_KEY }}
        run: |
          set -e
          TOK='${{ secrets.GHCR_TOKEN }}'
          USR='${{ secrets.GHCR_USERNAME }}'

          if [ -z "$TOK" ] || [ -z "$USR" ]; then
            echo "Error: GHCR_TOKEN and GHCR_USERNAME secrets must be set"
            exit 1
          fi

          success=0
          for i in 1 2 3; do
            echo "Attempt $i: Logging in to GHCR..."
            echo "$TOK" | docker login ${{ env.REGISTRY }} -u "$USR" --password-stdin

            if docker buildx build \
              --platform linux/amd64,linux/arm64 \
              --build-arg NEXT_PUBLIC_CLOUDFLARE_SITE_KEY=${NEXT_PUBLIC_CLOUDFLARE_SITE_KEY} \
              --provenance=false \
              --sbom=false \
              --cache-from type=registry,ref=${{ env.WEBSITE_IMAGE }}:buildcache \
              --cache-to type=registry,ref=${{ env.WEBSITE_IMAGE }}:buildcache,mode=max \
              -t ${{ env.WEBSITE_IMAGE }}:latest \
              -f Dockerfile \
              --push .; then
              echo "Website image buildx push succeeded"
              success=1
              break
            fi

            echo "Attempt $i failed; retrying in $((i*10))s..."
            sleep $((i*10))
          done

          if [ "$success" != 1 ]; then
            echo "Website image buildx push failed after 3 attempts"
            exit 1
          fi

      - name: Build multi-arch nginx image (with retry)
        run: |
          set -e
          TOK='${{ secrets.GHCR_TOKEN }}'
          USR='${{ secrets.GHCR_USERNAME }}'

          if [ -z "$TOK" ] || [ -z "$USR" ]; then
            echo "Error: GHCR_TOKEN and GHCR_USERNAME secrets must be set"
            exit 1
          fi

          success=0
          for i in 1 2 3; do
            echo "Attempt $i: Logging in to GHCR..."
            echo "$TOK" | docker login ${{ env.REGISTRY }} -u "$USR" --password-stdin

            if docker buildx build \
              --platform linux/amd64,linux/arm64 \
              --provenance=false \
              --sbom=false \
              --cache-from type=registry,ref=${{ env.NGINX_IMAGE }}:buildcache \
              --cache-to type=registry,ref=${{ env.NGINX_IMAGE }}:buildcache,mode=max \
              -t ${{ env.NGINX_IMAGE }}:latest \
              -f nginx/Dockerfile \
              --push .; then
              echo "Nginx image buildx push succeeded"
              success=1
              break
            fi

            echo "Attempt $i failed; retrying in $((i*10))s..."
            sleep $((i*10))
          done

          if [ "$success" != 1 ]; then
            echo "Nginx image buildx push failed after 3 attempts"
            exit 1
          fi

      - name: Retry website image push (redundant safety)
        run: |
          set -e
          for i in 1 2 3; do
            if docker pull ${{ env.WEBSITE_IMAGE }}:latest >/dev/null 2>&1; then
              echo "Website image available after buildx push"; break; fi
            echo "Attempt $i: verifying website image availability"; sleep $((i*5));
            if [ $i -eq 3 ]; then echo "Website image not retrievable"; exit 1; fi
          done

      - name: Retry nginx image push (redundant safety)
        run: |
          set -e
          for i in 1 2 3; do
            if docker pull ${{ env.NGINX_IMAGE }}:latest >/dev/null 2>&1; then
              echo "Nginx image available after buildx push"; break; fi
            echo "Attempt $i: verifying nginx image availability"; sleep $((i*5));
            if [ $i -eq 3 ]; then echo "Nginx image not retrievable"; exit 1; fi
          done
          set -e
          for i in 1 2 3; do
            if docker pull ${{ env.NGINX_IMAGE }}:latest >/dev/null 2>&1; then
              echo "Nginx image available after buildx push"; break; fi
            echo "Attempt $i: verifying nginx image availability"; sleep $((i*5));
            if [ $i -eq 3 ]; then echo "Nginx image not retrievable"; exit 1; fi
          done

      - name: Capture multi-arch image digests
        run: |
          set -e
          WEBSITE_DIGEST=$(docker buildx imagetools inspect ${{ env.WEBSITE_IMAGE }}:latest | awk '/Digest:/ {print $2; exit}')
          NGINX_DIGEST=$(docker buildx imagetools inspect ${{ env.NGINX_IMAGE }}:latest | awk '/Digest:/ {print $2; exit}')
          echo "Resolved website manifest digest: $WEBSITE_DIGEST"
          echo "Resolved nginx manifest digest: $NGINX_DIGEST"
          set -e
          WEBSITE_DIGEST=$(docker buildx imagetools inspect ${{ env.WEBSITE_IMAGE }}:latest | awk '/Digest:/ {print $2; exit}')
          NGINX_DIGEST=$(docker buildx imagetools inspect ${{ env.NGINX_IMAGE }}:latest | awk '/Digest:/ {print $2; exit}')
          echo "Resolved website manifest digest: $WEBSITE_DIGEST"
          echo "Resolved nginx manifest digest: $NGINX_DIGEST"
          echo "WEBSITE_DIGEST=$WEBSITE_DIGEST" >> $GITHUB_ENV
          echo "NGINX_DIGEST=$NGINX_DIGEST" >> $GITHUB_ENV
          printf '{"website":"%s","nginx":"%s"}' "$WEBSITE_DIGEST" "$NGINX_DIGEST" > image-digests.json

      - name: Upload image digest artifact
        uses: actions/upload-artifact@v4
        with:
          name: image-digests
          path: image-digests.json

  deploy:
    name: Deploy to EC2 via SSH with temporary IP allow
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read
      id-token: write
    env:
      WEBSITE_IMAGE: ghcr.io/${{ github.repository_owner }}/boudreaux/website
      NGINX_IMAGE: ghcr.io/${{ github.repository_owner }}/boudreaux/nginx
      # Align secret names: ensure AWS_SECURITY_GROUP_ID exists in repo secrets
      AWS_SECURITY_GROUP_ID: ${{ secrets.AWS_SECURITY_GROUP_ID }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download image digests artifact
        uses: actions/download-artifact@v4
        with:
          name: image-digests
          path: .

      - name: Export digest environment variables
        shell: bash
        run: |
          WEBSITE_DIGEST=$(jq -r '.website' image-digests.json)
          NGINX_DIGEST=$(jq -r '.nginx' image-digests.json)
          echo "WEBSITE_DIGEST=$WEBSITE_DIGEST" >> $GITHUB_ENV
          echo "NGINX_DIGEST=$NGINX_DIGEST" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get runner public IP
        id: ip
        uses: haythem/public-ip@v1.3

      - name: Temporarily whitelist runner IP for SSH
        run: |
          aws ec2 authorize-security-group-ingress \
            --group-id "$AWS_SECURITY_GROUP_ID" \
            --protocol tcp \
            --port 22 \
            --cidr "${{ steps.ip.outputs.ipv4 }}/32" || true

      - name: Create .env for remote
        run: |
          cat > .env.deploy << 'EOF'
          NEXT_APP_WEBSITE_IMAGE=${{ env.WEBSITE_IMAGE }}
          NEXT_APP_NGINX_IMAGE=${{ env.NGINX_IMAGE }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          AUTH_SECRET=${{ secrets.AUTH_SECRET }}
          # Align secret names: ensure NEXTAUTH_URL exists; if older name used, set alias in repo settings
          NEXTAUTH_URL=${{ secrets.NEXTAUTH_URL }}
          EMAIL_SERVER_HOST=${{ secrets.EMAIL_SERVER_HOST }}
          EMAIL_SERVER_PORT=${{ secrets.EMAIL_SERVER_PORT }}
          EMAIL_SERVER_USER=${{ secrets.EMAIL_SERVER_USER }}
          EMAIL_SERVER_PASSWORD=${{ secrets.EMAIL_SERVER_PASSWORD }}
          EMAIL_FROM=${{ secrets.EMAIL_FROM }}
          NEXT_PUBLIC_CLOUDFLARE_SITE_KEY=${{ secrets.NEXT_PUBLIC_CLOUDFLARE_SITE_KEY }}
          CLOUDFLARE_SECRET=${{ secrets.CLOUDFLARE_SECRET }}
          EOF

      - name: Upload compose + env
        uses: appleboy/scp-action@v0.1.7
        with:
          # Align secret names: EC2_HOST, EC2_USERNAME, SSH_PRIVATE_KEY
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: docker-compose.prod.yml,.env.deploy
          target: ~/boudreaux

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          timeout: 60s
          command_timeout: 30m
          envs: WEBSITE_DIGEST,NGINX_DIGEST
          script: |
            set -euo pipefail

            # Ensure SSH authorized_keys has correct permissions
            mkdir -p ~/.ssh
            chmod 700 ~/.ssh
            if [ -f ~/.ssh/authorized_keys ]; then
              chmod 600 ~/.ssh/authorized_keys
            fi

            cd ~/boudreaux

            # Ensure Docker is installed and running (Ubuntu)
            if ! command -v docker >/dev/null 2>&1; then
              sudo apt-get update
              sudo apt-get remove -y docker.io docker-doc docker-compose podman-docker containerd runc 2>/dev/null || true
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              if [ ! -f /etc/apt/keyrings/docker.gpg ]; then
                sudo install -m 0755 -d /etc/apt/keyrings
                curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                sudo chmod a+r /etc/apt/keyrings/docker.gpg
                echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                sudo apt-get update
              fi
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              sudo systemctl enable docker
              sudo systemctl start docker
              sudo usermod -aG docker $USER || true
            fi

            # Move env into place
            mv -f .env.deploy .env

            # Login to GHCR using aligned credentials
            echo '${{ secrets.GHCR_TOKEN }}' | docker login ghcr.io -u '${{ secrets.GHCR_USERNAME }}' --password-stdin

            WEBSITE_IMAGE='${{ env.WEBSITE_IMAGE }}'
            NGINX_IMAGE='${{ env.NGINX_IMAGE }}'

            # Capture previously deployed digests (if present)
            PREV_WEBSITE_DIGEST=$(docker inspect --format '{{index .RepoDigests 0}}' "$WEBSITE_IMAGE" 2>/dev/null || true)
            PREV_NGINX_DIGEST=$(docker inspect --format '{{index .RepoDigests 0}}' "$NGINX_IMAGE" 2>/dev/null || true)

            # If digests are provided, pin to those; otherwise, use latest and capture digests
            if [ -n "${WEBSITE_DIGEST:-}" ] && [ -n "${NGINX_DIGEST:-}" ]; then
              echo "Using provided digests for deployment"
              docker pull "$WEBSITE_DIGEST" || true
              docker pull "$NGINX_DIGEST" || true
              docker tag "$WEBSITE_DIGEST" "$WEBSITE_IMAGE:latest" || true
              docker tag "$NGINX_DIGEST" "$NGINX_IMAGE:latest" || true
              NEW_WEBSITE_DIGEST="$WEBSITE_DIGEST"
              NEW_NGINX_DIGEST="$NGINX_DIGEST"
            else
              echo "No digests provided; using latest tags"
              docker pull "$WEBSITE_IMAGE" || true
              docker pull "$NGINX_IMAGE" || true
              NEW_WEBSITE_DIGEST=$(docker inspect --format '{{index .RepoDigests 0}}' "$WEBSITE_IMAGE" 2>/dev/null || true)
              NEW_NGINX_DIGEST=$(docker inspect --format '{{index .RepoDigests 0}}' "$NGINX_IMAGE" 2>/dev/null || true)
            fi

            # Restart stack
            docker compose -f docker-compose.prod.yml down --remove-orphans || true
            docker compose -f docker-compose.prod.yml up -d

            # Basic health check
            sleep 5
            if ! curl -fsS --max-time 10 https://fakefourrecords.com/api/health; then
              echo 'Health check failed - attempting rollback'

              # Roll back to previous digests if we have them
              if [ -n "$PREV_WEBSITE_DIGEST" ]; then
                # Ensure previous digest is present and retag as :latest
                docker pull "$PREV_WEBSITE_DIGEST" || true
                docker tag "$PREV_WEBSITE_DIGEST" "$WEBSITE_IMAGE:latest" || true
              fi
              if [ -n "$PREV_NGINX_DIGEST" ]; then
                docker pull "$PREV_NGINX_DIGEST" || true
                docker tag "$PREV_NGINX_DIGEST" "$NGINX_IMAGE:latest" || true
              fi

              docker compose -f docker-compose.prod.yml up -d --force-recreate
              sleep 5
              if ! curl -fsS --max-time 10 https://fakefourrecords.com/api/health; then
                echo 'Rollback health check failed - manual intervention required'
                exit 1
              else
                echo 'Rollback successful'
              fi
            fi

            # Persist current digests on host for audit/rollback reference
            mkdir -p .deploy
            cat > .deploy/digests.json <<JSON
            {
              "website": {
                "prev": "${PREV_WEBSITE_DIGEST}",
                "current": "${NEW_WEBSITE_DIGEST}"
              },
              "nginx": {
                "prev": "${PREV_NGINX_DIGEST}",
                "current": "${NEW_NGINX_DIGEST}"
              }
            }
            JSON

            docker system prune -f || true

      - name: Revoke runner IP
        if: always()
        run: |
          aws ec2 revoke-security-group-ingress \
            --group-id "$AWS_SECURITY_GROUP_ID" \
            --protocol tcp \
            --port 22 \
            --cidr "${{ steps.ip.outputs.ipv4 }}/32" || true
