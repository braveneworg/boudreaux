name: Continuous Integration and Delivery

on:
  push:
    branches: [main]
env:
  NEXT_APP_WEBSITE_IMAGE: ghcr.io/${{ github.repository_owner }}/boudreaux/website
  NEXT_APP_NGINX_IMAGE: ghcr.io/${{ github.repository_owner }}/boudreaux/nginx
  REGISTRY: ghcr.io
jobs:
  build:
    name: Build All Docker Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v3

      - name: Set environment variables
        run: |
          echo "NEXT_APP_WEBSITE_IMAGE=ghcr.io/${{ github.repository_owner }}/boudreaux/website" >> $GITHUB_ENV
          echo "NEXT_APP_NGINX_IMAGE=ghcr.io/${{ github.repository_owner }}/boudreaux/nginx" >> $GITHUB_ENV
      - name: Log in to GitHub Packages
        env:
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          NGINX_SERVER_NAME: ${{ secrets.NGINX_SERVER_NAME }}
        run: echo "$PERSONAL_ACCESS_TOKEN" | docker login ghcr.io -u ${{ secrets.NAMESPACE }} --password-stdin

      - name: Build images
        run: |
          docker compose -f docker-compose.ci.yml build
      - name: Push images
        run: |
          docker push ${{ env.NEXT_APP_WEBSITE_IMAGE }}
          docker push ${{ env.NEXT_APP_NGINX_IMAGE }}
  deploy:
    name: Deploy to AWS EC2
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout main
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci

      - name: Sync media files to CDN
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
          CDN_DOMAIN: ${{ secrets.CDN_DOMAIN }}
        run: npm run sync:cdn:no-build

      - name: Add environment variables to .env
        run: |
          echo 'NEXT_APP_WEBSITE_IMAGE="${{ env.NEXT_APP_WEBSITE_IMAGE }}"' >> .env
          echo 'NEXT_APP_NGINX_IMAGE="${{ env.NEXT_APP_NGINX_IMAGE }}"' >> .env
          echo 'NAMESPACE="${{ secrets.NAMESPACE }}"' >> .env
          echo 'PERSONAL_ACCESS_TOKEN="${{ secrets.PERSONAL_ACCESS_TOKEN }}"' >> .env
          echo 'DATABASE_URL="${{ secrets.DATABASE_URL }}"' >> .env
          echo 'AUTH_SECRET="${{ secrets.AUTH_SECRET }}"' >> .env
          echo 'NEXTAUTH_URL="${{ secrets.NEXTAUTH_URL }}"' >> .env
          echo 'EMAIL_SERVER_HOST="${{ secrets.EMAIL_SERVER_HOST }}"' >> .env
          echo 'EMAIL_SERVER_PORT="${{ secrets.EMAIL_SERVER_PORT }}"' >> .env
          echo 'EMAIL_SERVER_USER="${{ secrets.EMAIL_SERVER_USER }}"' >> .env
          echo 'EMAIL_SERVER_PASSWORD="${{ secrets.EMAIL_SERVER_PASSWORD }}"' >> .env
          echo 'EMAIL_FROM="${{ secrets.EMAIL_FROM }}"' >> .env
          echo 'NEXT_PUBLIC_CLOUDFLARE_SITE_KEY="${{ secrets.NEXT_PUBLIC_CLOUDFLARE_SITE_KEY }}"' >> .env
          echo 'CLOUDFLARE_SECRET="${{ secrets.CLOUDFLARE_SECRET }}"' >> .env
      - name: Add the private SSH key to the ssh-agent
        env:
          SSH_AUTH_SOCK: /tmp/ssh_agent.sock
        run: |
          mkdir -p ~/.ssh
          ssh-agent -a $SSH_AUTH_SOCK > /dev/null
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          ssh-add - <<< "${{ secrets.PRIVATE_KEY }}"
      - name: Deploy images on AWS EC2
        env:
          SSH_AUTH_SOCK: /tmp/ssh_agent.sock
        run: |
          echo '${{secrets.PRIVATE_KEY}}' > /tmp/temp_key
          chmod 600 /tmp/temp_key

          # Delete files on remote server
          ssh -i /tmp/temp_key -o StrictHostKeyChecking=no ${{secrets.AWS_HOST_USER}}@${{ secrets.AWS_EC2_IP_ADDRESS }} "rm -f .env docker-compose.prod.yml"
          # Copy files to remote server

          echo '${{secrets.AWS_PRIVATE_KEY}}' > ./private_key.pem
          echo '${{secrets.AWS_CERTIFICATE}}' > ./certificate.pem
          chmod 644 ./certificate.pem
          chmod 600 ./private_key.pem
          scp -i /tmp/temp_key -o StrictHostKeyChecking=no -r ./.env ./docker-compose.prod.yml ./private_key.pem ./certificate.pem ${{secrets.AWS_HOST_USER}}@${{ secrets.AWS_EC2_IP_ADDRESS }}:

          # SSH and execute deployment commands
          ssh -i /tmp/temp_key -o StrictHostKeyChecking=no ${{secrets.AWS_HOST_USER}}@${{ secrets.AWS_EC2_IP_ADDRESS }} \
            NEXT_APP_WEBSITE_IMAGE='${{env.NEXT_APP_WEBSITE_IMAGE}}' NEXT_APP_NGINX_IMAGE='${{env.NEXT_APP_NGINX_IMAGE}}' PERSONAL_ACCESS_TOKEN='${{secrets.PERSONAL_ACCESS_TOKEN}}' NAMESPACE='${{secrets.NAMESPACE}}' \
            bash << 'EOF'
            set -e  # Exit on any error

            # Validate required variables
            if [ -z "${NEXT_APP_WEBSITE_IMAGE}" ] || [ -z "${NEXT_APP_NGINX_IMAGE}" ]; then
              echo "Error: Required environment variables are missing"
              exit 1
            fi

            # Update package lists
            sudo apt-get update

            # Remove conflicting packages
            sudo apt-get remove -y docker.io docker-doc docker-compose podman-docker containerd runc 2>/dev/null || true

            # Install prerequisites
            sudo apt-get install -y ca-certificates curl gnupg lsb-release

            # Set up Docker repository (only if not already done)
            if [ ! -f /etc/apt/keyrings/docker.gpg ]; then
              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              sudo chmod a+r /etc/apt/keyrings/docker.gpg

              # Add Docker repository
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "${VERSION_CODENAME}") stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

              sudo apt-get update
            fi

            # Install Docker from official repository (remove docker.io conflict)
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

            # Start Docker service
            sudo systemctl enable docker
            sudo systemctl start docker
            # Add user to docker group
            sudo usermod -aG docker $USER

            # Stop existing containers and clean up
            sudo docker compose -f docker-compose.prod.yml down --rmi all -v 2>/dev/null || true

            # Login to container registry
            echo "${PERSONAL_ACCESS_TOKEN}" | sudo docker login ghcr.io -u "${NAMESPACE}" --password-stdin

            # Pull latest images with proper quoting
            sudo docker pull "${NEXT_APP_WEBSITE_IMAGE}"
            sudo docker pull "${NEXT_APP_NGINX_IMAGE}"

            # Deploy with docker compose using .env file

            sudo docker compose -f docker-compose.prod.yml up -d

            # Logout and cleanup
            sudo docker logout

            # Clean up unused images and containers
            sudo docker system prune -f

            echo $WORKDIR

            echo "Deployment completed successfully"
          EOF

          # Clean up temporary SSH key
          rm /tmp/temp_key
