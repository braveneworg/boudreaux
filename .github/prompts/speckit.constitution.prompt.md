---
agent: speckit.constitution
---

# Project Constitution

## Core Principles

- Always use TypeScript version specified in the file package.json
- Use as const assertions instead of enums for better type safety and performance. Create a utils/enums.ts file to store all as const assertions for enums used across the project to maintain consistency and organization.
- Always use the latest stable version of TypeScript to take advantage of new features, improvements, and bug fixes. Regularly update the TypeScript version in the project to ensure compatibility with the latest language features and to maintain a modern and efficient development environment.
- Ensure strict mode is enabled in tsconfig.json to enforce stricter type checking and improve code quality. Strict mode helps catch potential errors and promotes better coding practices by enforcing more rigorous type checks, making the codebase more robust and maintainable.
- Use Next.js for all web development tasks, adhering to the latest stable release.
- Functionality should be implemented with a focus on performance and scalability.
- Functional programming paradigms should be favored where appropriate.
- Maintain a clean and organized codebase with clear separation of concerns.
- Adopt a test-driven development (TDD) approach to ensure code quality and reliability.
- Adhere to the DRY (Don't Repeat Yourself) principle to minimize code duplication.
- Use Git for version control, with clear and descriptive commit messages.
- Conduct code reviews for all pull requests to maintain code quality and share knowledge among team members.
- Prioritize security best practices in all aspects of development, including data handling and API design.
- Ensure that all dependencies are regularly updated and audited for vulnerabilities.
- Follow a consistent coding style, using Prettier for code formatting and ESLint for linting.
- Maintain a comprehensive README.md file that includes setup instructions, usage guidelines, and contribution guidelines for the project.
- Review and update the constitution periodically to reflect changes in technology, team practices, and project requirements.
- Review code for adherence to the constitution during code reviews and provide constructive feedback to ensure compliance.
- Follow Next.js App Router conventions (Server Components by default).
- Prioritize functional components with React Hooks.
- Use Tailwind CSS v4 for styling unless otherwise specified.
- Use Prisma as the ORM for database interactions, ensuring type safety and efficient querying.
- Use Zod for schema validation to ensure data integrity and type safety across the application.
- Use Tanstack Query for data fetching and state management to optimize performance and user experience.
- Access data via API routes, ensuring a clear separation between frontend and backend logic.
- Create services for complex business logic to maintain a clean and organized codebase.
- Use environment variables for configuration and sensitive information, ensuring they are not hardcoded in the codebase.
- Ensure that all API routes have proper authentication and authorization mechanisms in place to protect sensitive data and operations.
- Use GitHub Actions for continuous integration and deployment (CI/CD) to automate testing and deployment processes, ensuring that code changes are thoroughly tested before being merged and deployed.
- Use feature branches for new development and bug fixes, and merge them into the main branch only after passing all tests and code reviews.
- Maintain a clear and organized project structure, with separate directories for components, services, utilities, and tests to enhance maintainability and scalability.
- Encourage open communication and collaboration among team members, fostering a positive and productive work environment.
- Continuously seek feedback and opportunities for improvement in both code quality and team processes to ensure the ongoing success of the project.
- Adopt a mindset of continuous learning and improvement, staying up-to-date with the latest developments in web development technologies and best practices to ensure that the project remains modern and competitive.
- Promote a culture of code ownership and accountability, where each team member takes responsibility for the quality and maintainability of their code contributions.
- Ensure that all team members have access to the necessary resources and support to succeed in their roles, including documentation, training materials, and mentorship opportunities.
- Foster a culture of inclusivity and diversity within the team, valuing different perspectives and experiences to enhance creativity and innovation in the project.
- Encourage a healthy work-life balance for all team members, recognizing the importance of mental health and well-being in maintaining productivity and creativity in the long term.
- Regularly review and update the project constitution to reflect changes in technology, team practices, and project requirements, ensuring that it remains relevant and effective in guiding the development process.
- Promote a culture of transparency and open communication within the team, encouraging team members to share their ideas, concerns, and feedback openly to foster a collaborative and supportive work environment.
- Ensure that all team members are aligned with the project's goals and vision, fostering a shared sense of purpose and commitment to the success of the project.
- Encourage innovation and creativity in problem-solving, allowing team members to explore new approaches and technologies to enhance the project while adhering to the core principles outlined in this constitution.
- Use react-hook-form for form handling to simplify form state management and validation, ensuring a smooth user experience and efficient development process. Integrate with Zod for schema validation to maintain data integrity and type safety across the application.
- Always use server actions for data mutations to leverage Next.js's built-in capabilities for handling server-side logic and ensuring efficient data handling and security.
- Always use Prisma for database interactions to ensure type safety, efficient querying, and a consistent approach to data management across the application. Avoid direct database queries in API routes or components, and instead utilize Prisma's ORM capabilities to maintain a clean and organized codebase.
- Always use Tanstack Query for data fetching (no mutations; see using server actions above) and state management to optimize performance and user experience. Avoid manual data fetching and state management in components, and instead leverage Tanstack Query's features for caching, background updates, and synchronization with server state to ensure a responsive and efficient application.
- Always use environment variables for configuration and sensitive information, ensuring that they are not hardcoded in the codebase. Use a .env file for local development and ensure that sensitive information is securely stored and accessed in production environments, following best practices for managing secrets and configuration in web applications.

## Coding Standards

- No inline styles; use Tailwind v4 utility classes.
- Ensure all components are typed using interfaces or types.
- Never use the any type; prefer unknown if necessary.
- Avoid using non-null assertions (!); handle nullability explicitly.
- Always handle potential errors with try/catch blocks or error boundaries in React components.
- Use descriptive variable and function names that convey their purpose and intent.
- Avoid deeply nested code; refactor into smaller functions or components as needed.
- Ensure consistent use of semicolons and commas according to the project's coding style guidelines.
- Use async/await for asynchronous code, avoiding callback-based patterns to improve readability and maintainability.
- Always return a value from functions, even if it's void, to maintain consistency and clarity in function signatures.
- Ensure that all components and functions have clear and concise JSDoc comments describing their purpose, parameters, and return values for better maintainability and readability.
- Avoid using magic numbers or strings; define constants with meaningful names to improve code clarity and maintainability.
- Ensure that all code is properly formatted and linted according to the project's coding style guidelines, using Prettier for formatting and ESLint for linting to maintain a consistent codebase.
- Use destructuring assignment for objects and arrays to improve readability and reduce code verbosity.
- Avoid using global variables; instead, use local state or context to manage data within components and functions.
- Always prefer immutability when updating state or props to prevent unintended side effects and ensure predictable behavior.
- Avoid side effects in render methods; use effects or callbacks instead to handle any necessary side effects in React components.
- Ensure that all components are pure functions, avoiding any side effects or mutations to props or state to maintain predictability and ease of testing.
- Ensure that all API routes follow RESTful conventions and are organized logically within the project structure for maintainability and scalability.
- Always validate input data in API routes to prevent invalid data from being processed and to ensure the integrity of the application. Use Zod for schema validation to enforce data integrity and type safety across the application, ensuring that all incoming data is properly validated before being processed or stored.
- Never use eslint-disable comments; instead, address linting issues directly to maintain code quality and consistency across the codebase.
- Never use console.log for debugging; use a proper logging library or debugging tools to maintain a clean codebase and avoid leaving debug statements in production code.
- Never use alert or prompt for user interactions; instead, use custom modals or components to provide a better user experience and maintain control over the UI.
- Always use React's built-in state management and hooks for managing component state and side effects, avoiding external state management libraries unless absolutely necessary to maintain simplicity and consistency in the codebase.
- Ensure that all components are responsive and mobile-friendly, following best practices for responsive design and testing across different screen sizes and devices. Prefer mobile-first design principles to ensure a seamless user experience on all devices.
- Ensure that all API routes have proper authentication and authorization mechanisms in place to protect sensitive data and operations. Use secure authentication methods such as JWT or OAuth, and implement role-based access control (RBAC) to manage permissions effectively.
- Always sanitize and validate user input in API routes to prevent security vulnerabilities such as SQL injection, cross-site scripting (XSS), and other common attack vectors. Use libraries like DOMPurify for sanitization and Zod for validation to ensure data integrity and security.
- Ensure that all API routes have proper error handling and return appropriate HTTP status codes and error messages to provide clear feedback to clients and maintain a robust and user-friendly API.
- Use consistent naming conventions for API routes, such as using plural nouns for resource names (e.g., /api/users, /api/products) and following RESTful conventions for HTTP methods (GET for retrieval, POST for creation, PUT/PATCH for updates, DELETE for deletions) to maintain clarity and consistency in the API design.
- Ensure that all API routes are properly documented, including the expected request and response formats, authentication requirements, and any relevant error codes or messages to provide clear guidance for developers consuming the API. Use tools like Swagger or API Blueprint for comprehensive API documentation.
- Error handling must be explicit in all API routes.
- Accessibility (a11y) is mandatory; ensure proper ARIA labels.
- Use semantic HTML elements to enhance accessibility and improve the overall structure of the application, ensuring that assistive technologies can navigate and interpret the content effectively. Follow best practices for ARIA roles and attributes to provide additional context and information to users with disabilities, enhancing the usability of the application for all users.
- Never use deprecated HTML elements or attributes; always follow modern web standards and best practices to ensure compatibility and accessibility across different browsers and devices. Regularly review and update the codebase to remove any deprecated elements or attributes and replace them with modern alternatives that adhere to current web standards.
- Never use inline event handlers (e.g., onclick, onmouseover) in HTML; instead, use React's event handling system to manage events in a more organized and maintainable way. This approach helps keep the code clean and separates concerns between the structure of the HTML and the behavior of the application, improving readability and maintainability.
- Always use semantic HTML elements (e.g., <button>, <nav>, <header>,<main>, <footer>) to enhance the accessibility and structure of the application, ensuring that assistive technologies can navigate and interpret the content effectively. This practice also improves the overall user experience by providing a clear and meaningful structure to the content, making it easier for users to understand and interact with the application.
- Always ensure that all interactive elements, such as buttons and links, are keyboard accessible and have appropriate ARIA roles and attributes to provide a seamless experience for users with disabilities. Use tools like axe or Lighthouse to test the accessibility of components and ensure compliance with accessibility standards.
- Always ensure that all images have descriptive alt text to provide context for users with visual impairments and to improve SEO. Use meaningful and concise alt text that accurately describes the content and purpose of the image, enhancing the accessibility and usability of the application for all users.
- Always ensure that all form elements have associated labels to improve accessibility and usability for users with disabilities. Use the <label> element to associate labels with form controls, and ensure that the labels are descriptive and provide clear guidance on the expected input for each form field. Use the components I've already defined to be usable with react-hook-form for form elements to ensure consistency and accessibility across the application.
- Always ensure that all components and pages are designed to be responsive and mobile-friendly, following best practices for responsive design and testing across different screen sizes and devices to provide a seamless user experience on all platforms. Use CSS media queries and responsive design techniques to create components that adapt gracefully to different screen sizes and orientations, ensuring that the application remains usable and visually appealing on both desktop and mobile devices.
- Always ensure that all components and pages are designed with performance in mind, minimizing unnecessary re-renders and optimizing rendering performance to provide a smooth user experience. Use React's memoization techniques, such as React.memo and useMemo, to prevent unnecessary re-renders and optimize component performance. Use tools like React DevTools and performance profiling to identify and address performance bottlenecks in components.

## Testing & Quality

- Components should be modular and reusable.
- Ensure that all components are designed with reusability in mind, following the principles of modular design and separation of concerns to promote maintainability and scalability in the codebase. Use a consistent approach to component design, such as using functional components with React Hooks, to ensure a cohesive and efficient development process.
- Components should be designed to be easily testable, with clear input and output interfaces, and minimal side effects to facilitate unit testing and maintainability. Use dependency injection and mock external dependencies in tests to ensure that components can be tested in isolation and that tests are reliable and maintainable over time.
- Components should be designed with accessibility in mind, following best practices for ARIA roles and attributes to ensure that the application is usable by all users, including those with disabilities. Use tools like axe or Lighthouse to test and improve the accessibility of components and ensure compliance with accessibility standards.
- Components should be designed to be responsive and mobile-friendly, following best practices for responsive design and testing across different screen sizes and devices to ensure a seamless user experience on all platforms. Use CSS media queries and responsive design techniques to create components that adapt gracefully to different screen sizes and orientations. Always mobile-first design principles to ensure that components are optimized for smaller screens and provide a great user experience on mobile devices.
- Components should be designed with performance in mind, minimizing unnecessary re-renders and optimizing rendering performance to ensure a smooth user experience. Use React's memoization techniques, such as React.memo and useMemo, to prevent unnecessary re-renders and optimize component performance. Use tools like React DevTools and performance profiling to identify and address performance bottlenecks in components.
- Components should be designed to handle errors gracefully, with proper error boundaries and fallback UI to ensure a robust and user-friendly application. Use React's error boundary feature to catch and handle errors in components, providing a fallback UI that informs users of the issue without crashing the entire application. Ensure that error handling is consistent across components and provides clear feedback to users when issues arise.
- Components should be designed to be easily maintainable, with clear and concise code, proper documentation, and adherence to coding standards to facilitate ongoing development and refactoring efforts. Use consistent coding styles and patterns across components, and ensure that all code is well-documented with JSDoc comments to enhance readability and maintainability for current and future developers working on the project.
- Components should be designed to integrate seamlessly with the overall application architecture, following established patterns and conventions to ensure consistency and maintainability across the codebase. Use a consistent approach to component structure and organization, such as grouping related components together in directories and following naming conventions that reflect their purpose and functionality within the application.
- Components should be designed with scalability in mind, allowing for easy extension and modification as the application grows and evolves. Use design patterns and architectural principles that support scalability, such as component composition, state management best practices, and modular design.
- Components should be designed to be easily debuggable, with clear error messages and logging to facilitate troubleshooting and maintenance. Use tools like React DevTools and logging libraries to provide clear insights into component behavior and state, making it easier to identify and resolve issues during development and in production environments.
- Components should be designed to be easily integrated with testing frameworks, with clear input and output interfaces that facilitate unit testing and end-to-end testing to ensure a high level of test coverage and maintainability. Use tools like Vitest for unit testing and Playwright for end-to-end testing to cover different aspects of the application and ensure comprehensive test coverage.
- Components should be designed to be easily extendable, allowing for new features and functionality to be added without requiring significant refactoring or changes to existing code. Use design patterns such as higher-order components, render props, or hooks to enable extensibility while maintaining a clean and organized codebase.
- Ensure that all components are properly tested with a focus on both unit and end-to-end testing to maintain a high level of quality and reliability in the application. Use a combination of testing frameworks and tools, such as Vitest for unit testing and Playwright for end-to-end testing, to cover different aspects of the application and ensure comprehensive test coverage.
- Always use playwright for end-to-end testing to ensure that the application functions correctly from the user's perspective, covering critical user flows and edge cases to maintain a high level of quality and reliability in the application.
- Always write unit tests for all new functionality, ensuring that all code is thoroughly tested and that test coverage remains high across the codebase. Use Vitest for unit testing, and ensure that tests are organized and maintainable to facilitate ongoing development and refactoring efforts. Use jest-dom matchers for improved assertions in tests, providing more descriptive and accurate feedback when tests fail to enhance the debugging process and maintain a high level of test quality.
- Keep test files in the same directory as the code they are testing, with a .spec.ts extension for easy identification and organization.
- Remove orphaned tests when code is deleted or refactored to maintain a clean and relevant test suite.
- Remove orphaned code when tests are deleted or refactored to maintain a clean and relevant codebase.
- Ensure that all tests are deterministic and do not rely on external factors such as network requests or time-based functions to maintain reliability and consistency in test results.
- Always put the MPL 2.0 license header in all source files to ensure proper attribution and compliance with the project's licensing requirements. The MPL 2.0 license header should be included at the top of each source file, clearly indicating the licensing terms and providing proper attribution to the original authors of the code. This practice helps maintain transparency and ensures that the project adheres to open-source licensing standards.
- Always check type safety and code quality with Prettier and ESLint before committing code to the repository to maintain a consistent and high-quality codebase. Use pre-commit hooks to automate this process and ensure that all code meets the project's coding standards before being merged into the main branch.
- Always conduct code reviews for all pull requests to maintain code quality and share knowledge among team members. Use a collaborative approach to code reviews, providing constructive feedback and fostering a culture of continuous improvement within the team.
- Always use GitHub Actions for continuous integration and deployment (CI/CD) to automate testing and deployment processes, ensuring that code changes are thoroughly tested before being merged and deployed. Set up workflows to run tests, lint code, and deploy the application to production environments in a seamless and efficient manner, ensuring that the application remains stable and reliable as new features and changes are introduced.
- Always use feature branches for new development and bug fixes, and merge them into the main branch only after passing all tests and code reviews to maintain a clean and stable main branch. Use descriptive branch names that reflect the purpose of the branch, such as feature/new-feature or bugfix/fix-issue, to enhance clarity and organization in the development process.
- Maintain a clear and organized project structure, with separate directories for components, services, utilities, and tests to enhance maintainability and scalability. Use a consistent approach to organizing files and directories, such as grouping related components together and following naming conventions that reflect their purpose and functionality within the application. This structure helps developers navigate the codebase efficiently and promotes a clean and maintainable project organization.
- Quality should be prioritized over speed; take the time to write clean, maintainable code and comprehensive tests to ensure the long-term success of the project. Avoid rushing through development tasks, and instead focus on delivering high-quality code that adheres to the project's coding standards and best practices, even if it takes more time upfront. This approach helps prevent technical debt and ensures that the project remains maintainable and scalable as it evolves over time.
- When implementing new components or features, please look at the package.json file to see if there are any existing dependencies that can be leveraged to avoid adding unnecessary dependencies to the project. This practice helps maintain a lean and efficient codebase, reducing the risk of dependency bloat and ensuring that the project remains manageable and maintainable over time.
- When considering adding a new dependency to the project, evaluate whether the functionality can be implemented using existing dependencies or custom code before introducing a new library. This approach helps maintain a lean and efficient codebase, reducing the risk of dependency bloat and ensuring that the project remains manageable and maintainable over time.
- Always consider the trade-offs of adding a new dependency, such as increased bundle size, potential security vulnerabilities, and maintenance overhead, before deciding to include it in the project. Evaluate whether the benefits of the new dependency outweigh these potential drawbacks and ensure that it aligns with the project's goals and requirements before proceeding with its integration.
- Always ensure that any new dependencies added to the project are well-maintained, widely used, and have a strong community support to minimize the risk of introducing unstable or unmaintained libraries into the codebase. Conduct thorough research and evaluation of potential dependencies, including checking their GitHub repositories, issue trackers, and community forums to assess their reliability and suitability for the project before integrating them.
- Always ensure that any new dependencies added to the project are compatible with the existing technology stack and do not introduce conflicts or compatibility issues with other libraries or frameworks used in the project. Test new dependencies in a controlled environment before fully integrating them into the codebase to identify and address any potential issues early on.
- Always ensure that any new dependencies added to the project are properly documented, including their purpose, usage instructions, and any relevant configuration or setup steps to facilitate their use and maintenance within the project. Update the project's documentation, such as the README.md file or a dedicated dependencies section, to include information about the new dependency and how it fits into the overall architecture of the application.
- Always ensure that any new dependencies added to the project are regularly updated and maintained to address security vulnerabilities, bug fixes, and compatibility issues over time. Monitor the dependencies for updates and security advisories, and promptly update them as needed to maintain the security and stability of the application.
- Always ensure that any new dependencies added to the project are properly licensed and comply with the project's licensing requirements to avoid legal issues and ensure proper attribution. Review the licenses of potential dependencies to ensure they are compatible with the project's MPL 2.0 license and that they do not introduce any legal complications or restrictions.
- Use memoization, useCallback, and React.memo to optimize component performance and prevent unnecessary re-renders, ensuring a smooth user experience and efficient rendering of components. Analyze component performance using tools like React DevTools and performance profiling to identify areas where memoization can be applied effectively to enhance the responsiveness of the application.
- Use framer motion or motion.dev for animations to create smooth and visually appealing transitions and interactions within the application, enhancing the user experience and adding a polished feel to the UI. Leverage framer motion's powerful animation capabilities to create engaging and dynamic user interfaces that respond to user interactions in a natural and intuitive way. Use motion.dev for more complex animations and interactions that require advanced features and customization options to achieve the desired effects and behaviors in the application.
- Use React's Suspense and lazy loading features to optimize the loading performance of components and improve the overall user experience by reducing initial load times and enabling code splitting. Implement lazy loading for components that are not immediately necessary on page load, allowing the application to load faster and provide a smoother experience for users, especially on slower network connections or devices with limited resources.
- Use skeleton loaders and placeholders to improve the perceived performance of the application by providing visual feedback to users while content is loading, enhancing the user experience and reducing frustration during load times. Implement skeleton loaders for components that fetch data or perform asynchronous operations, giving users a clear indication that content is being loaded and improving the overall responsiveness of the application.
- Use React's Context API or a state management library like Redux or Zustand for managing global state in the application, ensuring that state is organized and accessible across components while maintaining a clear separation of concerns. Evaluate the complexity of the application's state management needs to determine whether the Context API is sufficient or if a more robust solution like Redux or Zustand is necessary to manage global state effectively.
- Use React's useEffect hook to handle side effects in components, such as data fetching, subscriptions, or manual DOM manipulations, ensuring that side effects are managed in a predictable and efficient manner. Use the dependency array in useEffect to control when the effect runs and to prevent unnecessary re-renders, ensuring that side effects are executed only when relevant data changes or when the component mounts or unmounts.
- Use React's useRef hook to manage mutable values that persist across renders, such as DOM references or timers, allowing for efficient handling of mutable state without triggering re-renders. Use useRef to store references to DOM elements, manage timers, or hold any mutable value that needs to persist across renders without causing re-renders, providing a flexible way to manage mutable state in functional components
- Use React's useReducer hook for managing complex state logic in components, providing a more structured and predictable way to handle state updates and actions compared to useState. Implement useReducer when the state logic involves multiple sub-values or when the next state depends on the previous state, allowing for better organization and maintainability of state management in components.
- Use React's useLayoutEffect hook for handling side effects that need to be executed synchronously after all DOM mutations, such as measuring layout or performing animations, ensuring that the UI updates are applied before the browser paints the screen. Use useLayoutEffect when you need to perform operations that require access to the DOM immediately after changes have been made, such as calculating element positions or sizes, to ensure that the UI remains responsive and visually consistent.
- Use React's useImperativeHandle hook to customize the instance value that is exposed to parent components when using refs, allowing for more controlled and encapsulated component APIs. Implement useImperativeHandle to expose specific methods or properties to parent components while keeping the internal implementation of the child component hidden, promoting encapsulation and a clear separation of concerns in component design.
- Use React's useDebugValue hook to provide custom labels for custom hooks in React DevTools, enhancing the debugging experience and making it easier to understand the state and behavior of custom hooks during development. Implement useDebugValue in custom hooks to display relevant information about the hook's state or behavior in React DevTools, providing developers with insights into how the hook is functioning and aiding in troubleshooting and optimization efforts.
- Use React's useTransition hook to manage concurrent UI updates and improve the responsiveness of the application by allowing certain updates to be deferred while keeping the UI responsive. Implement useTransition to mark certain state updates as non-urgent, allowing React to prioritize more critical updates and maintain a smooth user experience even during heavy rendering or data fetching operations.
- Use React's useDeferredValue hook to defer the rendering of non-critical updates, improving the performance and responsiveness of the application by allowing more important updates to be rendered first. Implement useDeferredValue to delay the rendering of certain components or updates until after more critical updates have been processed, enhancing the overall user experience and performance of the application.
- Use React's useId hook to generate unique IDs for components, ensuring that they are consistent across server and client renders and avoiding issues with hydration in Next.js applications. Implement useId to generate stable and unique IDs for elements that require them, such as form inputs and labels, to ensure proper accessibility and functionality in both server-rendered and client-rendered environments.
- Use React's useSyncExternalStore hook to subscribe to external stores and ensure that components stay in sync with external state changes, providing a reliable way to manage subscriptions and updates in React applications. Implement useSyncExternalStore to connect components to external data sources or state management libraries, ensuring that components receive updates in a consistent and efficient manner while maintaining the integrity of the application's state.
- Use React's useInsertionEffect hook to inject styles or perform other side effects that need to occur before any DOM mutations, ensuring that styles are applied correctly and efficiently in the application. Implement useInsertionEffect for scenarios where you need to insert styles or perform operations that must happen before the browser applies any changes to the DOM, such as when using CSS-in-JS libraries or managing dynamic styles in components.
